#pragma once

#include <cmath>
#include <cstdint>

/// Microtuning system: converts MIDI note numbers to frequencies
/// using different tuning systems.
/// All tables pre-computed â€” O(1) lookup, RT-safe.
class Microtuning {
public:
  enum class System : int {
    TwelveTET = 0,  // Equal temperament
    JustIntonation, // Pure ratios
    Pythagorean,    // Circle of fifths
    Count
  };

  static constexpr int kMidiNotes = 128;

  Microtuning() { setSystem(System::TwelveTET, 440.0f); }

  /// Set tuning system and reference pitch (A4 frequency).
  /// Pre-computes the full 128-note frequency table.
  void setSystem(System system, float referencePitch) {
    currentSystem = system;
    refPitch = referencePitch;
    buildTable();
  }

  void setReferencePitch(float pitch) {
    refPitch = pitch;
    buildTable();
  }

  /// Get frequency for MIDI note. O(1) lookup.
  float getFrequency(int midiNote) const {
    if (midiNote < 0)
      midiNote = 0;
    if (midiNote > 127)
      midiNote = 127;
    return freqTable[midiNote];
  }

  /// Get frequency in cents relative to 12-TET for a given interval.
  /// Useful for testing tuning accuracy.
  static float ratioToCents(float ratio) { return 1200.0f * std::log2(ratio); }

  /// Get the cents offset of a note from 12-TET.
  float getCentsFromTET(int midiNote) const {
    float tetFreq = refPitch * std::pow(2.0f, (midiNote - 69.0f) / 12.0f);
    float actualFreq = getFrequency(midiNote);
    if (tetFreq <= 0.0f || actualFreq <= 0.0f)
      return 0.0f;
    return 1200.0f * std::log2(actualFreq / tetFreq);
  }

  System getSystem() const { return currentSystem; }
  float getReferencePitch() const { return refPitch; }

private:
  void buildTable() {
    switch (currentSystem) {
    case System::TwelveTET:
      buildTwelveTET();
      break;
    case System::JustIntonation:
      buildJustIntonation();
      break;
    case System::Pythagorean:
      buildPythagorean();
      break;
    default:
      buildTwelveTET();
      break;
    }
  }

  void buildTwelveTET() {
    // Standard equal temperament: f = refPitch * 2^((n - 69) / 12)
    for (int n = 0; n < kMidiNotes; ++n)
      freqTable[n] = refPitch * std::pow(2.0f, (n - 69.0f) / 12.0f);
  }

  void buildJustIntonation() {
    // Just Intonation ratios relative to the root (C).
    // These are the standard 5-limit just intervals.
    static constexpr float justRatios[12] = {
        1.0f,          // Unison       (C)
        16.0f / 15.0f, // Minor 2nd    (C#/Db)
        9.0f / 8.0f,   // Major 2nd    (D)
        6.0f / 5.0f,   // Minor 3rd    (D#/Eb)
        5.0f / 4.0f,   // Major 3rd    (E)
        4.0f / 3.0f,   // Perfect 4th  (F)
        45.0f / 32.0f, // Tritone      (F#/Gb)
        3.0f / 2.0f,   // Perfect 5th  (G)
        8.0f / 5.0f,   // Minor 6th    (G#/Ab)
        5.0f / 3.0f,   // Major 6th    (A)
        9.0f / 5.0f,   // Minor 7th    (A#/Bb)
        15.0f / 8.0f   // Major 7th    (B)
    };

    // MIDI note 69 = A4 = refPitch.
    // A is degree 9. MIDI 69 is in octave 69/12 = 5 (integer division).
    // C in that octave = MIDI 60 (octave 5).
    // So: refPitch = c5 * justRatios[9], where c5 is C in octave 5.
    // MIDI note n: octave = n / 12, degree = n % 12.
    // freq = c_octave0 * 2^octave * justRatios[degree]
    // c_octave0 = refPitch / (justRatios[9] * std::pow(2.0f, 5.0f))
    float cOctave0 = refPitch / (justRatios[9] * std::pow(2.0f, 5.0f));

    for (int n = 0; n < kMidiNotes; ++n) {
      int octave = n / 12;
      int degree = n % 12;
      float octaveMultiplier = std::pow(2.0f, static_cast<float>(octave));
      freqTable[n] = cOctave0 * justRatios[degree] * octaveMultiplier;
    }
  }

  void buildPythagorean() {
    // Pythagorean tuning: all intervals derived from 3:2 ratio.
    // Generated by stacking perfect fifths.
    static constexpr float pythRatios[12] = {
        1.0f,            // C   (unison)
        256.0f / 243.0f, // C#  (limma)
        9.0f / 8.0f,     // D   (major tone)
        32.0f / 27.0f,   // Eb  (minor 3rd)
        81.0f / 64.0f,   // E   (ditone / major 3rd)
        4.0f / 3.0f,     // F   (perfect 4th)
        729.0f / 512.0f, // F#  (tritone)
        3.0f / 2.0f,     // G   (perfect 5th)
        128.0f / 81.0f,  // Ab  (minor 6th)
        27.0f / 16.0f,   // A   (major 6th)
        16.0f / 9.0f,    // Bb  (minor 7th)
        243.0f / 128.0f  // B   (major 7th)
    };

    // Same octave derivation as JI
    float cOctave0 = refPitch / (pythRatios[9] * std::pow(2.0f, 5.0f));

    for (int n = 0; n < kMidiNotes; ++n) {
      int octave = n / 12;
      int degree = n % 12;
      float octaveMultiplier = std::pow(2.0f, static_cast<float>(octave));
      freqTable[n] = cOctave0 * pythRatios[degree] * octaveMultiplier;
    }
  }

  float freqTable[kMidiNotes] = {};
  System currentSystem = System::TwelveTET;
  float refPitch = 440.0f;
};
